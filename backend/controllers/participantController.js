// TODO: Implement Mahotsav participant allocation logic
// Controllers for participant check-in, creation, payment update, and room allocation
// IMPORTANT: MHID is NOT generated - participants come with existing MHID

const Participant = require('../models/Participant');
const Room = require('../models/Room');

/**
 * Controller: Check MHID
 * Checks if a participant with given MHID exists in the database
 * Returns participant data if found, null if not found
 * DOMAIN RULE: MHID is NOT generated by system - only CHECK and STORE
 */
const checkMHID = async (req, res) => {
  try {
    // Support both GET (params) and POST (body) methods
    const mhid = req.params.mhid || req.body.mhid;

    // Validate input
    if (!mhid) {
      return res.status(400).json({
        success: false,
        message: 'MHID is required'
      });
    }

    // Search for participant
    const participant = await Participant.findOne({ 
      mhid: mhid.toUpperCase().trim() 
    });

    if (participant) {
      return res.status(200).json({
        success: true,
        message: 'Participant found',
        data: participant
      });
    } else {
      return res.status(404).json({
        success: false,
        message: 'Participant not found',
        data: null
      });
    }
  } catch (error) {
    console.error('Error in checkMHID:', error);
    return res.status(500).json({
      success: false,
      message: 'Server error while checking MHID',
      error: error.message
    });
  }
};

/**
 * Controller: Create Participant
 * Creates a new participant entry
 * DOMAIN RULES:
 * - If MHID already exists, returns existing record (no new entry)
 * - If MHID does not exist → create with paymentStatus = "Unpaid" and no room
 * - Gender must be "Boys" or "Girls"
 */
const createParticipant = async (req, res) => {
  try {
    const { mhid, name, gender, contactNumber, email, college } = req.body;

    // Validate required fields
    if (!mhid || !name || !gender || !contactNumber) {
      return res.status(400).json({
        success: false,
        message: 'MHID, name, gender, and contactNumber are required'
      });
    }

    // Validate gender
    if (!['Boy', 'Girl'].includes(gender)) {
      return res.status(400).json({
        success: false,
        message: 'Gender must be either "Boy" or "Girl"'
      });
    }

    // Check if participant already exists
    const existingParticipant = await Participant.findOne({ 
      mhid: mhid.toUpperCase().trim() 
    });

    if (existingParticipant) {
      return res.status(200).json({
        success: true,
        message: 'Participant already exists',
        data: existingParticipant,
        isExisting: true
      });
    }

    // Create new participant - default paymentStatus = "Unpaid", no room
    const newParticipant = new Participant({
      mhid: mhid.toUpperCase().trim(),
      name: name.trim(),
      gender: gender,
      contactNumber: contactNumber.trim(),
      email: email ? email.trim() : '',
      college: college ? college.trim() : '',
      paymentStatus: 'Unpaid',
      allocationStatus: 'Not Allocated',
      roomNumber: null,
      allocatedBy: null
    });

    await newParticipant.save();

    return res.status(201).json({
      success: true,
      message: 'Participant created successfully',
      data: newParticipant,
      isExisting: false
    });
  } catch (error) {
    console.error('Error in createParticipant:', error);
    
    // Handle duplicate key error
    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'Participant with this MHID already exists'
      });
    }

    // Handle validation errors
    if (error.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: Object.values(error.errors).map(err => err.message)
      });
    }

    return res.status(500).json({
      success: false,
      message: 'Server error while creating participant',
      error: error.message
    });
  }
};

/**
 * Controller: Manual Payment Update
 * Updates payment status manually (admin/volunteer action)
 * DOMAIN RULES:
 * - NO payment gateway - manual verification
 * - Does NOT allocate any room
 * - Admin verifies payment proof and updates status
 */
const updatePaymentStatus = async (req, res) => {
  try {
    const { mhid, paymentStatus } = req.body;

    // Validate input
    if (!mhid || !paymentStatus) {
      return res.status(400).json({
        success: false,
        message: 'MHID and payment status are required'
      });
    }

    // Validate payment status value
    if (!['Paid', 'Unpaid'].includes(paymentStatus)) {
      return res.status(400).json({
        success: false,
        message: 'Payment status must be either "Paid" or "Unpaid"'
      });
    }

    // Find and update participant
    const participant = await Participant.findOne({ 
      mhid: mhid.toUpperCase().trim() 
    });

    if (!participant) {
      return res.status(404).json({
        success: false,
        message: 'Participant not found'
      });
    }

    // Update payment status (does NOT allocate room)
    participant.paymentStatus = paymentStatus;
    await participant.save();

    return res.status(200).json({
      success: true,
      message: `Payment status updated to ${paymentStatus}`,
      data: participant
    });
  } catch (error) {
    console.error('Error in updatePaymentStatus:', error);
    return res.status(500).json({
      success: false,
      message: 'Server error while updating payment status',
      error: error.message
    });
  }
};

/**
 * Controller: Room Allocation (AUTOMATIC or MANUAL)
 * DOMAIN RULES (STRICTLY FOLLOWED):
 * 1. If MHID exists and room is already allocated → SHOW the same room (never change)
 * 2. If MHID exists but payment is "Unpaid" → DO NOT allocate room
 * 3. If roomNumber provided → MANUAL allocation (coordinator selects)
 * 4. If no roomNumber → AUTOMATIC allocation (system finds available room)
 * 5. If participant data provided (name, gender, etc.) → Create participant first, then allocate
 */
const allocateRoom = async (req, res) => {
  try {
    let { mhid, roomNumber, name, gender, college, mobile, email, paymentStatus, amountPaid } = req.body;

    // Validate MHID
    if (!mhid) {
      return res.status(400).json({
        success: false,
        message: 'MHID is required'
      });
    }

    mhid = mhid.toUpperCase().trim();

    // Find or create participant
    let participant = await Participant.findOne({ mhid });

    // If participant doesn't exist and we have the data, create them first
    if (!participant && name && gender) {
      const status = paymentStatus || 'Unpaid';  // Default to Unpaid for safety
      
      participant = new Participant({
        mhid,
        name,
        college: college || 'Not specified',
        gender,
        contactNumber: mobile || 'Not provided',
        email: email || 'Not provided',
        paymentStatus: status,
        amountPaid: amountPaid || 0
      });
      await participant.save();
      
      // If creating as Unpaid, stop here - do not allocate room
      if (status !== 'Paid') {
        return res.status(200).json({
          success: true,
          message: 'Participant created as Unpaid. Please verify payment before room allocation.',
          data: { participant },
          requiresPayment: true
        });
      }
    }

    if (!participant) {
      return res.status(404).json({
        success: false,
        message: 'Participant not found. Please provide participant details (name, gender, etc.)'
      });
    }

    // RULE 1: If room already allocated → SHOW the same room (never change)
    if (participant.allocationStatus === 'Allocated' && participant.roomNumber) {
      const allocatedRoom = await Room.findOne({ roomNumber: participant.roomNumber });
      
      return res.status(200).json({
        success: true,
        message: 'Participant already has a room allocated',
        data: { participant, room: allocatedRoom },
        alreadyAllocated: true
      });
    }

    // RULE 2: STRICT - If payment is "Unpaid" → ABSOLUTELY DO NOT allocate room
    // This rule is ENFORCED - no room allocation without payment verification
    if (participant.paymentStatus !== 'Paid') {
      return res.status(400).json({
        success: false,
        message: 'CANNOT ALLOCATE ROOM: Payment status must be "Paid". Please verify payment first.',
        data: participant,
        paymentRequired: true
      });
    }

    let selectedRoom;

    // AUTOMATIC ALLOCATION: Find available room of matching gender
    if (!roomNumber) {
      selectedRoom = await Room.findAvailableByGender(participant.gender);
      
      if (!selectedRoom) {
        return res.status(400).json({
          success: false,
          message: `No available rooms for ${participant.gender}. All rooms are full.`
        });
      }
    } else {
      // MANUAL ALLOCATION: Use provided room number
      selectedRoom = await Room.findOne({ roomNumber: parseInt(roomNumber) });

      if (!selectedRoom) {
        return res.status(404).json({
          success: false,
          message: `Room ${roomNumber} not found`
        });
      }

      // Validate gender match
      if (selectedRoom.gender !== participant.gender) {
        return res.status(400).json({
          success: false,
          message: `Room gender mismatch. Participant is ${participant.gender}, but room is for ${selectedRoom.gender}`
        });
      }

      // Check capacity
      if (!selectedRoom.hasCapacity()) {
        return res.status(400).json({
          success: false,
          message: `Room ${roomNumber} is full. Please select another room.`
        });
      }
    }

    // Atomic allocation - increment occupiedCount and allocate room
    const roomIncremented = selectedRoom.incrementOccupied();
    
    if (!roomIncremented) {
      return res.status(400).json({
        success: false,
        message: 'Room became full during allocation. Please try again.'
      });
    }

    await selectedRoom.save();

    // Allocate room to participant (permanent - never changes)
    participant.allocateRoom(selectedRoom.roomNumber);
    participant.allocatedBy = req.user ? req.user.name : 'System';
    await participant.save();

    return res.status(201).json({
      success: true,
      message: `Room ${selectedRoom.roomNumber} allocated successfully`,
      data: { participant, room: selectedRoom },
      alreadyAllocated: false
    });
  } catch (error) {
    console.error('Error in allocateRoom:', error);
    return res.status(500).json({
      success: false,
      message: 'Server error while allocating room',
      error: error.message
    });
  }
};

/**
 * Controller: Update Participant Details
 * Updates participant information (name, contact, payment status, gender)
 * DOMAIN RULE: MHID cannot be changed once created
 */
const updateParticipant = async (req, res) => {
  try {
    const { mhid } = req.params;
    const { name, contactNumber, paymentStatus, gender, email, college } = req.body;

    // Validate MHID
    if (!mhid) {
      return res.status(400).json({
        success: false,
        message: 'MHID is required'
      });
    }

    // Find participant
    const participant = await Participant.findOne({ mhid: mhid.toUpperCase().trim() });

    if (!participant) {
      return res.status(404).json({
        success: false,
        message: 'Participant not found'
      });
    }

    // Validate and update fields
    const updates = {};

    if (name !== undefined) {
      const trimmedName = name.trim();
      if (!trimmedName) {
        return res.status(400).json({
          success: false,
          message: 'Name cannot be empty'
        });
      }
      // Validate name contains only letters and spaces
      if (!/^[a-zA-Z\s]+$/.test(trimmedName)) {
        return res.status(400).json({
          success: false,
          message: 'Name can only contain letters and spaces'
        });
      }
      updates.name = trimmedName;
    }

    if (contactNumber !== undefined) {
      // Allow empty contact number or validate if provided
      if (contactNumber.trim() !== '') {
        // Validate 10-digit number
        if (!/^\d{10}$/.test(contactNumber.trim())) {
          return res.status(400).json({
            success: false,
            message: 'Contact number must be exactly 10 digits'
          });
        }
        updates.contactNumber = contactNumber.trim();
      } else {
        updates.contactNumber = '';
      }
    }

    if (paymentStatus !== undefined) {
      if (!['Paid', 'Unpaid'].includes(paymentStatus)) {
        return res.status(400).json({
          success: false,
          message: 'Payment status must be either "Paid" or "Unpaid"'
        });
      }
      updates.paymentStatus = paymentStatus;
    }

    if (gender !== undefined) {
      if (!['Boy', 'Girl'].includes(gender)) {
        return res.status(400).json({
          success: false,
          message: 'Gender must be either "Boy" or "Girl"'
        });
      }
      
      // If gender is being changed and participant is allocated, check if new gender matches room
      if (participant.allocationStatus === 'Allocated' && participant.roomNumber) {
        const room = await Room.findOne({ roomNumber: participant.roomNumber });
        if (room && room.gender !== gender) {
          return res.status(400).json({
            success: false,
            message: `Cannot change gender to ${gender}. Participant is allocated to a ${room.gender} room. Please deallocate first.`
          });
        }
      }
      
      updates.gender = gender;
    }

    if (email !== undefined) {
      const trimmedEmail = (email || '').trim().toLowerCase();
      // Basic email format check (optional)
      if (trimmedEmail && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmedEmail)) {
        return res.status(400).json({
          success: false,
          message: 'Invalid email format'
        });
      }
      updates.email = trimmedEmail;
    }

    if (college !== undefined) {
      updates.college = (college || '').trim();
    }

    // Update participant
    Object.assign(participant, updates);
    await participant.save();

    return res.status(200).json({
      success: true,
      message: 'Participant updated successfully',
      data: participant
    });

  } catch (error) {
    console.error('Error in updateParticipant:', error);
    return res.status(500).json({
      success: false,
      message: 'Server error while updating participant',
      error: error.message
    });
  }
};

module.exports = {
  checkMHID,
  createParticipant,
  updatePaymentStatus,
  allocateRoom,
  updateParticipant
};
